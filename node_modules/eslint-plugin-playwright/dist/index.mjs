var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/utils/ast.ts
function getStringValue(node) {
  if (!node)
    return "";
  return node.type === "Identifier" ? node.name : node.type === "TemplateLiteral" ? node.quasis[0].value.raw : node.type === "Literal" && typeof node.value === "string" ? node.value : "";
}
function getRawValue(node) {
  return node.type === "Literal" ? node.raw : void 0;
}
function isIdentifier(node, name) {
  return node.type === "Identifier" && (typeof name === "string" ? node.name === name : name.test(node.name));
}
function isLiteral(node, type, value) {
  return node.type === "Literal" && (value === void 0 ? typeof node.value === type : node.value === value);
}
function isStringLiteral(node, value) {
  return isLiteral(node, "string", value);
}
function isBooleanLiteral(node, value) {
  return isLiteral(node, "boolean", value);
}
function isStringNode(node) {
  return node && (isStringLiteral(node) || isTemplateLiteral(node));
}
function isPropertyAccessor(node, name) {
  return getStringValue(node.property) === name;
}
function isTestIdentifier(node) {
  return isIdentifier(node, "test") || node.type === "MemberExpression" && isIdentifier(node.object, "test");
}
function isDescribeCall(node) {
  const inner = node.type === "CallExpression" ? node.callee : node;
  if (isIdentifier(inner, "describe")) {
    return true;
  }
  if (inner.type !== "MemberExpression") {
    return false;
  }
  return isPropertyAccessor(inner, "describe") ? true : describeProperties.has(getStringValue(inner.property)) ? isDescribeCall(inner.object) : false;
}
function findParent(node, type) {
  if (!node.parent)
    return;
  return node.parent.type === type ? node.parent : findParent(node.parent, type);
}
function isTestCall(node, modifiers) {
  return isTestIdentifier(node.callee) && !isDescribeCall(node) && (node.callee.type !== "MemberExpression" || !modifiers || modifiers?.includes(getStringValue(node.callee.property))) && node.arguments.length === 2 && ["ArrowFunctionExpression", "FunctionExpression"].includes(
    node.arguments[1].type
  );
}
function isTestHook(node) {
  return node.callee.type === "MemberExpression" && isIdentifier(node.callee.object, "test") && testHooks.has(getStringValue(node.callee.property));
}
function getExpectType(node) {
  if (isIdentifier(node.callee, /(^expect|Expect)$/)) {
    return "standalone";
  }
  if (node.callee.type === "MemberExpression" && isIdentifier(node.callee.object, "expect")) {
    const type = getStringValue(node.callee.property);
    return expectSubCommands.has(type) ? type : void 0;
  }
}
function isExpectCall(node) {
  return !!getExpectType(node);
}
function getMatchers(node, chain = []) {
  if (node.parent.type === "MemberExpression" && node.parent.object === node) {
    return getMatchers(node.parent, [
      ...chain,
      node.parent.property
    ]);
  }
  return chain;
}
function dig(node, identifier) {
  return node.type === "MemberExpression" ? dig(node.property, identifier) : node.type === "CallExpression" ? dig(node.callee, identifier) : node.type === "Identifier" ? isIdentifier(node, identifier) : false;
}
function isPageMethod(node, name) {
  return node.callee.type === "MemberExpression" && dig(node.callee.object, /(^(page|frame)|(Page|Frame)$)/) && isPropertyAccessor(node.callee, name);
}
var isTemplateLiteral, describeProperties, testHooks, expectSubCommands;
var init_ast = __esm({
  "src/utils/ast.ts"() {
    "use strict";
    isTemplateLiteral = (node, value) => node.type === "TemplateLiteral" && node.quasis.length === 1 && // bail out if not simple
    (value === void 0 || node.quasis[0].value.raw === value);
    describeProperties = /* @__PURE__ */ new Set([
      "parallel",
      "serial",
      "only",
      "skip",
      "fixme"
    ]);
    testHooks = /* @__PURE__ */ new Set(["afterAll", "afterEach", "beforeAll", "beforeEach"]);
    expectSubCommands = /* @__PURE__ */ new Set(["soft", "poll"]);
  }
});

// src/utils/misc.ts
function getAdditionalAssertFunctionNames(context) {
  const globalSettings = context.settings.playwright?.additionalAssertFunctionNames ?? [];
  const ruleSettings = context.options[0]?.additionalAssertFunctionNames ?? [];
  return [...globalSettings, ...ruleSettings];
}
var getAmountData;
var init_misc = __esm({
  "src/utils/misc.ts"() {
    "use strict";
    getAmountData = (amount) => ({
      amount: amount.toString(),
      s: amount === 1 ? "" : "s"
    });
  }
});

// src/rules/expect-expect.ts
function isAssertionCall(node, additionalAssertFunctionNames) {
  return isExpectCall(node) || additionalAssertFunctionNames.find((name) => dig(node.callee, name));
}
var expect_expect_default;
var init_expect_expect = __esm({
  "src/rules/expect-expect.ts"() {
    "use strict";
    init_ast();
    init_misc();
    expect_expect_default = {
      create(context) {
        const sourceCode = context.sourceCode ?? context.getSourceCode();
        const unchecked = [];
        const additionalAssertFunctionNames = getAdditionalAssertFunctionNames(context);
        function checkExpressions(nodes) {
          for (const node of nodes) {
            const index = node.type === "CallExpression" ? unchecked.indexOf(node) : -1;
            if (index !== -1) {
              unchecked.splice(index, 1);
              break;
            }
          }
        }
        return {
          CallExpression(node) {
            if (isTestCall(node, ["fixme", "only", "skip"])) {
              unchecked.push(node);
            } else if (isAssertionCall(node, additionalAssertFunctionNames)) {
              const ancestors = sourceCode.getAncestors ? sourceCode.getAncestors(node) : context.getAncestors();
              checkExpressions(ancestors);
            }
          },
          "Program:exit"() {
            unchecked.forEach((node) => {
              context.report({ messageId: "noAssertions", node });
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Enforce assertion to be made in a test body",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/expect-expect.md"
        },
        messages: {
          noAssertions: "Test has no assertions"
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              additionalAssertFunctionNames: {
                items: [{ type: "string" }],
                type: "array"
              }
            },
            type: "object"
          }
        ],
        type: "problem"
      }
    };
  }
});

// src/rules/max-nested-describe.ts
var max_nested_describe_default;
var init_max_nested_describe = __esm({
  "src/rules/max-nested-describe.ts"() {
    "use strict";
    init_ast();
    max_nested_describe_default = {
      create(context) {
        const { options } = context;
        const max = options[0]?.max ?? 5;
        const describeCallbackStack = [];
        function pushDescribeCallback(node) {
          if (node.parent.type !== "CallExpression" || !isDescribeCall(node.parent)) {
            return;
          }
          describeCallbackStack.push(0);
          if (describeCallbackStack.length > max) {
            context.report({
              data: {
                depth: describeCallbackStack.length.toString(),
                max: max.toString()
              },
              messageId: "exceededMaxDepth",
              node: node.parent.callee
            });
          }
        }
        function popDescribeCallback(node) {
          const { parent } = node;
          if (parent.type === "CallExpression" && isDescribeCall(parent)) {
            describeCallbackStack.pop();
          }
        }
        return {
          ArrowFunctionExpression: pushDescribeCallback,
          "ArrowFunctionExpression:exit": popDescribeCallback,
          FunctionExpression: pushDescribeCallback,
          "FunctionExpression:exit": popDescribeCallback
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Enforces a maximum depth to nested describe calls",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/max-nested-describe.md"
        },
        messages: {
          exceededMaxDepth: "Maximum describe call depth exceeded ({{ depth }}). Maximum allowed is {{ max }}."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              max: {
                minimum: 0,
                type: "integer"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/rules/missing-playwright-await.ts
function getCallType(node, awaitableMatchers) {
  if (node.callee.type === "MemberExpression" && isIdentifier(node.callee.object, "test") && isPropertyAccessor(node.callee, "step")) {
    return { messageId: "testStep", node };
  }
  const expectType = getExpectType(node);
  if (!expectType)
    return;
  const [lastMatcher] = getMatchers(node).slice(-1);
  const grandparent = lastMatcher?.parent?.parent;
  if (grandparent?.type !== "CallExpression")
    return;
  const matcherName = getStringValue(lastMatcher);
  if (expectType === "poll" || awaitableMatchers.has(matcherName)) {
    return {
      data: { matcherName },
      messageId: expectType === "poll" ? "expectPoll" : "expect",
      node: grandparent
    };
  }
}
var validTypes, expectPlaywrightMatchers, playwrightTestMatchers, missing_playwright_await_default;
var init_missing_playwright_await = __esm({
  "src/rules/missing-playwright-await.ts"() {
    "use strict";
    init_ast();
    validTypes = /* @__PURE__ */ new Set([
      "AwaitExpression",
      "ReturnStatement",
      "ArrowFunctionExpression"
    ]);
    expectPlaywrightMatchers = [
      "toBeChecked",
      "toBeDisabled",
      "toBeEnabled",
      "toEqualText",
      // deprecated
      "toEqualUrl",
      "toEqualValue",
      "toHaveFocus",
      "toHaveSelector",
      "toHaveSelectorCount",
      "toHaveText",
      // deprecated
      "toMatchAttribute",
      "toMatchComputedStyle",
      "toMatchText",
      "toMatchTitle",
      "toMatchURL",
      "toMatchValue"
    ];
    playwrightTestMatchers = [
      "toBeChecked",
      "toBeDisabled",
      "toBeEditable",
      "toBeEmpty",
      "toBeEnabled",
      "toBeFocused",
      "toBeHidden",
      "toBeVisible",
      "toContainText",
      "toHaveAttribute",
      "toHaveClass",
      "toHaveCount",
      "toHaveCSS",
      "toHaveId",
      "toHaveJSProperty",
      "toBeOK",
      "toHaveScreenshot",
      "toHaveText",
      "toHaveTitle",
      "toHaveURL",
      "toHaveValue",
      "toHaveValues",
      "toBeAttached",
      "toBeInViewport"
    ];
    missing_playwright_await_default = {
      create(context) {
        const sourceCode = context.sourceCode ?? context.getSourceCode();
        const options = context.options[0] || {};
        const awaitableMatchers = /* @__PURE__ */ new Set([
          ...expectPlaywrightMatchers,
          ...playwrightTestMatchers,
          // Add any custom matchers to the set
          ...options.customMatchers || []
        ]);
        function checkValidity(node) {
          if (validTypes.has(node.parent.type))
            return true;
          if (node.parent.type === "ArrayExpression") {
            return checkValidity(node.parent);
          }
          if (node.parent.type === "CallExpression" && node.parent.callee.type === "MemberExpression" && isIdentifier(node.parent.callee.object, "Promise") && isIdentifier(node.parent.callee.property, "all")) {
            return true;
          }
          if (node.parent.type === "VariableDeclarator") {
            const scope = sourceCode.getScope(node.parent.parent);
            for (const ref of scope.references) {
              const refParent = ref.identifier.parent;
              if (validTypes.has(refParent.type))
                return true;
              if (checkValidity(refParent))
                return true;
            }
          }
          return false;
        }
        return {
          CallExpression(node) {
            const result = getCallType(node, awaitableMatchers);
            const isValid = result ? checkValidity(result.node) : false;
            if (result && !isValid) {
              context.report({
                data: result.data,
                fix: (fixer) => fixer.insertTextBefore(node, "await "),
                messageId: result.messageId,
                node: node.callee
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: `Identify false positives when async Playwright APIs are not properly awaited.`,
          recommended: true
        },
        fixable: "code",
        messages: {
          expect: "'{{matcherName}}' must be awaited or returned.",
          expectPoll: "'expect.poll' matchers must be awaited or returned.",
          testStep: "'test.step' must be awaited or returned."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              customMatchers: {
                items: { type: "string" },
                type: "array"
              }
            },
            type: "object"
          }
        ],
        type: "problem"
      }
    };
  }
});

// src/rules/no-conditional-in-test.ts
var no_conditional_in_test_default;
var init_no_conditional_in_test = __esm({
  "src/rules/no-conditional-in-test.ts"() {
    "use strict";
    init_ast();
    no_conditional_in_test_default = {
      create(context) {
        function checkConditional(node) {
          const call = findParent(node, "CallExpression");
          if (call && isTestCall(call)) {
            context.report({ messageId: "conditionalInTest", node });
          }
        }
        return {
          ConditionalExpression: checkConditional,
          IfStatement: checkConditional,
          LogicalExpression: checkConditional,
          SwitchStatement: checkConditional
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Disallow conditional logic in tests",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-conditional-in-test.md"
        },
        messages: {
          conditionalInTest: "Avoid having conditionals in tests"
        },
        schema: [],
        type: "problem"
      }
    };
  }
});

// src/rules/no-element-handle.ts
function getPropertyRange(node) {
  return node.type === "Identifier" ? node.range : [node.range[0] + 1, node.range[1] - 1];
}
var no_element_handle_default;
var init_no_element_handle = __esm({
  "src/rules/no-element-handle.ts"() {
    "use strict";
    init_ast();
    no_element_handle_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (isPageMethod(node, "$") || isPageMethod(node, "$$")) {
              context.report({
                messageId: "noElementHandle",
                node: node.callee,
                suggest: [
                  {
                    fix: (fixer) => {
                      const { property } = node.callee;
                      const fixes = [
                        fixer.replaceTextRange(
                          getPropertyRange(property),
                          "locator"
                        )
                      ];
                      if (node.parent.type === "AwaitExpression") {
                        fixes.push(
                          fixer.removeRange([
                            node.parent.range[0],
                            node.range[0]
                          ])
                        );
                      }
                      return fixes;
                    },
                    messageId: isPageMethod(node, "$") ? "replaceElementHandleWithLocator" : "replaceElementHandlesWithLocator"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "The use of ElementHandle is discouraged, use Locator instead",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-element-handle.md"
        },
        hasSuggestions: true,
        messages: {
          noElementHandle: "Unexpected use of element handles.",
          replaceElementHandlesWithLocator: "Replace `page.$$` with `page.locator`",
          replaceElementHandleWithLocator: "Replace `page.$` with `page.locator`"
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/no-eval.ts
var no_eval_default;
var init_no_eval = __esm({
  "src/rules/no-eval.ts"() {
    "use strict";
    init_ast();
    no_eval_default = {
      create(context) {
        return {
          CallExpression(node) {
            const isEval = isPageMethod(node, "$eval");
            if (isEval || isPageMethod(node, "$$eval")) {
              context.report({
                messageId: isEval ? "noEval" : "noEvalAll",
                node: node.callee
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "The use of `page.$eval` and `page.$$eval` are discouraged, use `locator.evaluate` or `locator.evaluateAll` instead",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-eval.md"
        },
        messages: {
          noEval: "Unexpected use of page.$eval().",
          noEvalAll: "Unexpected use of page.$$eval()."
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-focused-test.ts
var no_focused_test_default;
var init_no_focused_test = __esm({
  "src/rules/no-focused-test.ts"() {
    "use strict";
    init_ast();
    no_focused_test_default = {
      create(context) {
        return {
          CallExpression(node) {
            if ((isTestCall(node) || isDescribeCall(node)) && node.callee.type === "MemberExpression" && isPropertyAccessor(node.callee, "only")) {
              const { callee } = node;
              context.report({
                messageId: "noFocusedTest",
                node: node.callee.property,
                suggest: [
                  {
                    // - 1 to remove the `.only` annotation with dot notation
                    fix: (fixer) => fixer.removeRange([
                      callee.property.range[0] - 1,
                      callee.range[1]
                    ]),
                    messageId: "suggestRemoveOnly"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "Prevent usage of `.only()` focus test annotation",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-focused-test.md"
        },
        hasSuggestions: true,
        messages: {
          noFocusedTest: "Unexpected focused test.",
          suggestRemoveOnly: "Remove .only() annotation."
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-force-option.ts
function isForceOptionEnabled(node) {
  const arg = node.arguments[node.arguments.length - 1];
  return arg?.type === "ObjectExpression" && arg.properties.find(
    (property) => property.type === "Property" && getStringValue(property.key) === "force" && isBooleanLiteral(property.value, true)
  );
}
var methodsWithForceOption, no_force_option_default;
var init_no_force_option = __esm({
  "src/rules/no-force-option.ts"() {
    "use strict";
    init_ast();
    methodsWithForceOption = /* @__PURE__ */ new Set([
      "check",
      "uncheck",
      "click",
      "dblclick",
      "dragTo",
      "fill",
      "hover",
      "selectOption",
      "selectText",
      "setChecked",
      "tap"
    ]);
    no_force_option_default = {
      create(context) {
        return {
          MemberExpression(node) {
            if (methodsWithForceOption.has(getStringValue(node.property)) && node.parent.type === "CallExpression") {
              const reportNode = isForceOptionEnabled(node.parent);
              if (reportNode) {
                context.report({ messageId: "noForceOption", node: reportNode });
              }
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Prevent usage of `{ force: true }` option.",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-force-option.md"
        },
        messages: {
          noForceOption: "Unexpected use of { force: true } option."
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/no-nested-step.ts
function isStepCall(node) {
  const inner = node.type === "CallExpression" ? node.callee : node;
  if (inner.type !== "MemberExpression") {
    return false;
  }
  return isPropertyAccessor(inner, "step");
}
var no_nested_step_default;
var init_no_nested_step = __esm({
  "src/rules/no-nested-step.ts"() {
    "use strict";
    init_ast();
    no_nested_step_default = {
      create(context) {
        const stack = [];
        function pushStepCallback(node) {
          if (node.parent.type !== "CallExpression" || !isStepCall(node.parent)) {
            return;
          }
          stack.push(0);
          if (stack.length > 1) {
            context.report({
              messageId: "noNestedStep",
              node: node.parent.callee
            });
          }
        }
        function popStepCallback(node) {
          const { parent } = node;
          if (parent.type === "CallExpression" && isStepCall(parent)) {
            stack.pop();
          }
        }
        return {
          ArrowFunctionExpression: pushStepCallback,
          "ArrowFunctionExpression:exit": popStepCallback,
          FunctionExpression: pushStepCallback,
          "FunctionExpression:exit": popStepCallback
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Disallow nested `test.step()` methods",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-nested-step.md"
        },
        messages: {
          noNestedStep: "Do not nest `test.step()` methods."
        },
        schema: [],
        type: "problem"
      }
    };
  }
});

// src/rules/no-networkidle.ts
var messageId, methods, no_networkidle_default;
var init_no_networkidle = __esm({
  "src/rules/no-networkidle.ts"() {
    "use strict";
    init_ast();
    messageId = "noNetworkidle";
    methods = /* @__PURE__ */ new Set([
      "goBack",
      "goForward",
      "goto",
      "reload",
      "setContent",
      "waitForLoadState",
      "waitForURL"
    ]);
    no_networkidle_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (node.callee.type !== "MemberExpression")
              return;
            const methodName = getStringValue(node.callee.property);
            if (!methods.has(methodName))
              return;
            if (methodName === "waitForLoadState") {
              const arg = node.arguments[0];
              if (arg && isStringLiteral(arg, "networkidle")) {
                context.report({ messageId, node: arg });
              }
              return;
            }
            if (node.arguments.length >= 2) {
              const [_, arg] = node.arguments;
              if (arg.type !== "ObjectExpression")
                return;
              const property = arg.properties.filter((p) => p.type === "Property").find((p) => isStringLiteral(p.value, "networkidle"));
              if (property) {
                context.report({ messageId, node: property.value });
              }
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "Prevent usage of the networkidle option",
          recommended: true
        },
        messages: {
          noNetworkidle: "Unexpected use of networkidle."
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-nth-methods.ts
var methods2, no_nth_methods_default;
var init_no_nth_methods = __esm({
  "src/rules/no-nth-methods.ts"() {
    "use strict";
    init_ast();
    methods2 = /* @__PURE__ */ new Set(["first", "last", "nth"]);
    no_nth_methods_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (node.callee.type !== "MemberExpression")
              return;
            const method = getStringValue(node.callee.property);
            if (!methods2.has(method))
              return;
            context.report({
              data: { method },
              loc: {
                end: node.loc.end,
                start: node.callee.property.loc.start
              },
              messageId: "noNthMethod"
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Disallow usage of nth methods",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-nth-methods.md"
        },
        messages: {
          noNthMethod: "Unexpected use of {{method}}()"
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-page-pause.ts
var no_page_pause_default;
var init_no_page_pause = __esm({
  "src/rules/no-page-pause.ts"() {
    "use strict";
    init_ast();
    no_page_pause_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (isPageMethod(node, "pause")) {
              context.report({ messageId: "noPagePause", node });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "Prevent usage of page.pause()",
          recommended: true
        },
        messages: {
          noPagePause: "Unexpected use of page.pause()."
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-raw-locators.ts
function normalize(str) {
  const match = /\[([^=]+?)=['"]?([^'"]+?)['"]?\]/.exec(str);
  return match ? `[${match[1]}=${match[2]}]` : str;
}
var no_raw_locators_default;
var init_no_raw_locators = __esm({
  "src/rules/no-raw-locators.ts"() {
    "use strict";
    init_ast();
    no_raw_locators_default = {
      create(context) {
        const options = {
          allowed: [],
          ...context.options?.[0] ?? {}
        };
        function isAllowed(arg) {
          return options.allowed.some((a) => normalize(a) === normalize(arg));
        }
        return {
          CallExpression(node) {
            if (node.callee.type !== "MemberExpression")
              return;
            const method = getStringValue(node.callee.property);
            const arg = getStringValue(node.arguments[0]);
            const isLocator = isPageMethod(node, "locator") || method === "locator";
            if (isLocator && !isAllowed(arg)) {
              context.report({ messageId: "noRawLocator", node });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Disallows the usage of raw locators",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-raw-locators.md"
        },
        messages: {
          noRawLocator: "Usage of raw locator detected. Use methods like .getByRole() or .getByText() instead of raw locators."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              allowed: {
                items: { type: "string" },
                type: "array"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/utils/parseExpectCall.ts
function getExpectArguments(node) {
  const grandparent = node.parent.parent;
  return grandparent.type === "CallExpression" ? grandparent.arguments : [];
}
function parseExpectCall(node) {
  if (!isExpectCall(node)) {
    return;
  }
  const members = getMatchers(node);
  const modifiers = [];
  let matcher;
  members.forEach((item) => {
    if (MODIFIER_NAMES.has(getStringValue(item))) {
      modifiers.push(item);
    } else {
      matcher = item;
    }
  });
  if (!matcher) {
    return;
  }
  return {
    args: getExpectArguments(matcher),
    matcher,
    matcherName: getStringValue(matcher),
    members,
    modifiers
  };
}
var MODIFIER_NAMES;
var init_parseExpectCall = __esm({
  "src/utils/parseExpectCall.ts"() {
    "use strict";
    init_ast();
    MODIFIER_NAMES = /* @__PURE__ */ new Set(["not", "resolves", "rejects"]);
  }
});

// src/rules/no-restricted-matchers.ts
var no_restricted_matchers_default;
var init_no_restricted_matchers = __esm({
  "src/rules/no-restricted-matchers.ts"() {
    "use strict";
    init_ast();
    init_parseExpectCall();
    no_restricted_matchers_default = {
      create(context) {
        const restrictedChains = context.options?.[0] ?? {};
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall)
              return;
            Object.entries(restrictedChains).map(([restriction, message]) => {
              const chain = expectCall.members;
              const restrictionLinks = restriction.split(".").length;
              const startIndex = chain.findIndex((_, i) => {
                const partial = chain.slice(i, i + restrictionLinks).map(getStringValue).join(".");
                return partial === restriction;
              });
              return {
                // If the restriction chain was found, return the portion of the
                // chain that matches the restriction chain.
                chain: startIndex !== -1 ? chain.slice(startIndex, startIndex + restrictionLinks) : [],
                message,
                restriction
              };
            }).filter(({ chain }) => chain.length).forEach(({ chain, message, restriction }) => {
              context.report({
                data: { message: message ?? "", restriction },
                loc: {
                  end: chain[chain.length - 1].loc.end,
                  start: chain[0].loc.start
                },
                messageId: message ? "restrictedWithMessage" : "restricted"
              });
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Disallow specific matchers & modifiers",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-restricted-matchers.md"
        },
        messages: {
          restricted: "Use of `{{restriction}}` is disallowed",
          restrictedWithMessage: "{{message}}"
        },
        schema: [
          {
            additionalProperties: {
              type: ["string", "null"]
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/rules/no-skipped-test.ts
var no_skipped_test_default;
var init_no_skipped_test = __esm({
  "src/rules/no-skipped-test.ts"() {
    "use strict";
    init_ast();
    no_skipped_test_default = {
      create(context) {
        return {
          CallExpression(node) {
            const options = context.options[0] || {};
            const allowConditional = !!options.allowConditional;
            const { callee } = node;
            if ((isTestIdentifier(callee) || isDescribeCall(node)) && callee.type === "MemberExpression" && isPropertyAccessor(callee, "skip")) {
              const isHook = isTestCall(node) || isDescribeCall(node);
              if (!isHook && allowConditional && node.arguments.length) {
                return;
              }
              context.report({
                messageId: "noSkippedTest",
                node: isHook ? callee.property : node,
                suggest: [
                  {
                    fix: (fixer) => {
                      return isHook ? fixer.removeRange([
                        callee.property.range[0] - 1,
                        callee.range[1]
                      ]) : fixer.remove(node.parent);
                    },
                    messageId: "removeSkippedTestAnnotation"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Prevent usage of the `.skip()` skip test annotation.",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-skipped-test.md"
        },
        hasSuggestions: true,
        messages: {
          noSkippedTest: "Unexpected use of the `.skip()` annotation.",
          removeSkippedTestAnnotation: "Remove the `.skip()` annotation."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              allowConditional: {
                default: false,
                type: "boolean"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/rules/no-useless-await.ts
function isSupportedMethod(node) {
  if (node.callee.type !== "MemberExpression")
    return false;
  const name = getStringValue(node.callee.property);
  return locatorMethods.has(name) || pageMethods.has(name) && isPageMethod(node, name);
}
var locatorMethods, pageMethods, no_useless_await_default;
var init_no_useless_await = __esm({
  "src/rules/no-useless-await.ts"() {
    "use strict";
    init_ast();
    locatorMethods = /* @__PURE__ */ new Set([
      "and",
      "first",
      "getByAltText",
      "getByLabel",
      "getByPlaceholder",
      "getByRole",
      "getByTestId",
      "getByText",
      "getByTitle",
      "last",
      "locator",
      "nth",
      "or"
    ]);
    pageMethods = /* @__PURE__ */ new Set([
      "childFrames",
      "frame",
      "frameLocator",
      "frames",
      "isClosed",
      "isDetached",
      "mainFrame",
      "name",
      "on",
      "page",
      "parentFrame",
      "setDefaultNavigationTimeout",
      "setDefaultTimeout",
      "url",
      "video",
      "viewportSize",
      "workers"
    ]);
    no_useless_await_default = {
      create(context) {
        return {
          AwaitExpression(node) {
            if (node.argument.type !== "CallExpression")
              return;
            const { callee } = node.argument;
            if (callee.type !== "MemberExpression")
              return;
            if (!isSupportedMethod(node.argument))
              return;
            const start = node.loc.start;
            const range = node.range;
            context.report({
              fix: (fixer) => fixer.removeRange([range[0], range[0] + 6]),
              loc: {
                end: {
                  column: start.column + 5,
                  line: start.line
                },
                start
              },
              messageId: "noUselessAwait"
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "Disallow unnecessary awaits for Playwright methods",
          recommended: true
        },
        fixable: "code",
        messages: {
          noUselessAwait: "Unnecessary await expression. This method does not return a Promise."
        },
        type: "problem"
      }
    };
  }
});

// src/utils/fixer.ts
function replaceAccessorFixer(fixer, node, text) {
  const [start, end] = node.range;
  return fixer.replaceTextRange(
    [start + getRangeOffset(node), end - getRangeOffset(node)],
    text
  );
}
var getRangeOffset;
var init_fixer = __esm({
  "src/utils/fixer.ts"() {
    "use strict";
    getRangeOffset = (node) => node.type === "Identifier" ? 0 : 1;
  }
});

// src/rules/no-useless-not.ts
var matcherMap, no_useless_not_default;
var init_no_useless_not = __esm({
  "src/rules/no-useless-not.ts"() {
    "use strict";
    init_ast();
    init_fixer();
    init_parseExpectCall();
    matcherMap = {
      toBeDisabled: "toBeEnabled",
      toBeEnabled: "toBeDisabled",
      toBeHidden: "toBeVisible",
      toBeVisible: "toBeHidden"
    };
    no_useless_not_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall)
              return;
            const notModifier = expectCall.modifiers.find(
              (mod) => getStringValue(mod) === "not"
            );
            if (!notModifier)
              return;
            if (expectCall.matcherName in matcherMap) {
              const newMatcher = matcherMap[expectCall.matcherName];
              context.report({
                data: { new: newMatcher, old: expectCall.matcherName },
                fix: (fixer) => [
                  fixer.removeRange([
                    notModifier.range[0] - getRangeOffset(notModifier),
                    notModifier.range[1] + 1
                  ]),
                  replaceAccessorFixer(fixer, expectCall.matcher, newMatcher)
                ],
                loc: {
                  end: expectCall.matcher.loc.end,
                  start: notModifier.loc.start
                },
                messageId: "noUselessNot"
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: `Disallow usage of 'not' matchers when a more specific matcher exists`,
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-useless-not.md"
        },
        fixable: "code",
        messages: {
          noUselessNot: "Unexpected usage of not.{{old}}(). Use {{new}}() instead."
        },
        type: "problem"
      }
    };
  }
});

// src/rules/no-wait-for-selector.ts
var no_wait_for_selector_default;
var init_no_wait_for_selector = __esm({
  "src/rules/no-wait-for-selector.ts"() {
    "use strict";
    init_ast();
    no_wait_for_selector_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (isPageMethod(node, "waitForSelector")) {
              context.report({
                messageId: "noWaitForSelector",
                node,
                suggest: [
                  {
                    fix: (fixer) => fixer.remove(
                      node.parent && node.parent.type !== "AwaitExpression" ? node.parent : node.parent.parent
                    ),
                    messageId: "removeWaitForSelector"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Prevent usage of page.waitForSelector()",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-wait-for-selector.md"
        },
        hasSuggestions: true,
        messages: {
          noWaitForSelector: "Unexpected use of page.waitForSelector().",
          removeWaitForSelector: "Remove the page.waitForSelector() method."
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/no-wait-for-timeout.ts
var no_wait_for_timeout_default;
var init_no_wait_for_timeout = __esm({
  "src/rules/no-wait-for-timeout.ts"() {
    "use strict";
    init_ast();
    no_wait_for_timeout_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (isPageMethod(node, "waitForTimeout")) {
              context.report({
                messageId: "noWaitForTimeout",
                node,
                suggest: [
                  {
                    fix: (fixer) => fixer.remove(
                      node.parent && node.parent.type !== "AwaitExpression" ? node.parent : node.parent.parent
                    ),
                    messageId: "removeWaitForTimeout"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Prevent usage of page.waitForTimeout()",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/no-wait-for-timeout.md"
        },
        hasSuggestions: true,
        messages: {
          noWaitForTimeout: "Unexpected use of page.waitForTimeout().",
          removeWaitForTimeout: "Remove the page.waitForTimeout() method."
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-lowercase-title.ts
var prefer_lowercase_title_default;
var init_prefer_lowercase_title = __esm({
  "src/rules/prefer-lowercase-title.ts"() {
    "use strict";
    init_ast();
    prefer_lowercase_title_default = {
      create(context) {
        const { allowedPrefixes, ignore, ignoreTopLevelDescribe } = {
          allowedPrefixes: [],
          ignore: [],
          ignoreTopLevelDescribe: false,
          ...context.options?.[0] ?? {}
        };
        let describeCount = 0;
        return {
          CallExpression(node) {
            const method = isDescribeCall(node) ? "test.describe" : isTestCall(node) ? "test" : null;
            if (method === "test.describe") {
              describeCount++;
              if (ignoreTopLevelDescribe && describeCount === 1) {
                return;
              }
            } else if (!method) {
              return;
            }
            const [title] = node.arguments;
            if (!isStringNode(title)) {
              return;
            }
            const description = getStringValue(title);
            if (!description || allowedPrefixes.some((name) => description.startsWith(name))) {
              return;
            }
            const firstCharacter = description.charAt(0);
            if (!firstCharacter || firstCharacter === firstCharacter.toLowerCase() || ignore.includes(method)) {
              return;
            }
            context.report({
              data: { method },
              fix(fixer) {
                const rangeIgnoringQuotes = [
                  title.range[0] + 1,
                  title.range[1] - 1
                ];
                const newDescription = description.substring(0, 1).toLowerCase() + description.substring(1);
                return fixer.replaceTextRange(rangeIgnoringQuotes, newDescription);
              },
              messageId: "unexpectedLowercase",
              node: node.arguments[0]
            });
          },
          "CallExpression:exit"(node) {
            if (isDescribeCall(node)) {
              describeCount--;
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Enforce lowercase test names",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-lowercase-title.md"
        },
        fixable: "code",
        messages: {
          unexpectedLowercase: "`{{method}}`s should begin with lowercase"
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              allowedPrefixes: {
                additionalItems: false,
                items: { type: "string" },
                type: "array"
              },
              ignore: {
                additionalItems: false,
                items: {
                  enum: ["test.describe", "test"]
                },
                type: "array"
              },
              ignoreTopLevelDescribe: {
                default: false,
                type: "boolean"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-strict-equal.ts
var prefer_strict_equal_default;
var init_prefer_strict_equal = __esm({
  "src/rules/prefer-strict-equal.ts"() {
    "use strict";
    init_fixer();
    init_parseExpectCall();
    prefer_strict_equal_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (expectCall?.matcherName === "toEqual") {
              context.report({
                messageId: "useToStrictEqual",
                node: expectCall.matcher,
                suggest: [
                  {
                    fix: (fixer) => {
                      return replaceAccessorFixer(
                        fixer,
                        expectCall.matcher,
                        "toStrictEqual"
                      );
                    },
                    messageId: "suggestReplaceWithStrictEqual"
                  }
                ]
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Suggest using `toStrictEqual()`",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-strict-equal.md"
        },
        fixable: "code",
        hasSuggestions: true,
        messages: {
          suggestReplaceWithStrictEqual: "Replace with `toStrictEqual()`",
          useToStrictEqual: "Use toStrictEqual() instead"
        },
        schema: [],
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-to-be.ts
function shouldUseToBe(expectCall) {
  let arg = expectCall.args[0];
  if (arg.type === "UnaryExpression" && arg.operator === "-") {
    arg = arg.argument;
  }
  if (arg.type === "Literal") {
    return !("regex" in arg);
  }
  return arg.type === "TemplateLiteral";
}
function reportPreferToBe(context, expectCall, whatToBe, notModifier) {
  context.report({
    fix(fixer) {
      const fixes = [
        replaceAccessorFixer(fixer, expectCall.matcher, `toBe${whatToBe}`)
      ];
      if (expectCall.args?.length && whatToBe !== "") {
        fixes.push(fixer.remove(expectCall.args[0]));
      }
      if (notModifier) {
        const [start, end] = notModifier.range;
        fixes.push(fixer.removeRange([start - 1, end]));
      }
      return fixes;
    },
    messageId: `useToBe${whatToBe}`,
    node: expectCall.matcher
  });
}
var prefer_to_be_default;
var init_prefer_to_be = __esm({
  "src/rules/prefer-to-be.ts"() {
    "use strict";
    init_ast();
    init_fixer();
    init_parseExpectCall();
    prefer_to_be_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall)
              return;
            const notMatchers = ["toBeUndefined", "toBeDefined"];
            const notModifier = expectCall.modifiers.find(
              (node2) => getStringValue(node2) === "not"
            );
            if (notModifier && notMatchers.includes(expectCall.matcherName)) {
              return reportPreferToBe(
                context,
                expectCall,
                expectCall.matcherName === "toBeDefined" ? "Undefined" : "Defined",
                notModifier
              );
            }
            const argumentMatchers = ["toBe", "toEqual", "toStrictEqual"];
            const firstArg = expectCall.args[0];
            if (!argumentMatchers.includes(expectCall.matcherName) || !firstArg) {
              return;
            }
            if (firstArg.type === "Literal" && firstArg.value === null) {
              return reportPreferToBe(context, expectCall, "Null");
            }
            if (isIdentifier(firstArg, "undefined")) {
              const name = notModifier ? "Defined" : "Undefined";
              return reportPreferToBe(context, expectCall, name, notModifier);
            }
            if (isIdentifier(firstArg, "NaN")) {
              return reportPreferToBe(context, expectCall, "NaN");
            }
            if (shouldUseToBe(expectCall) && expectCall.matcherName !== "toBe") {
              reportPreferToBe(context, expectCall, "");
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Suggest using `toBe()` for primitive literals",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-to-be.md"
        },
        fixable: "code",
        messages: {
          useToBe: "Use `toBe` when expecting primitive literals",
          useToBeDefined: "Use `toBeDefined` instead",
          useToBeNaN: "Use `toBeNaN` instead",
          useToBeNull: "Use `toBeNull` instead",
          useToBeUndefined: "Use `toBeUndefined` instead"
        },
        schema: [],
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-to-contain.ts
var matchers, isFixableIncludesCallExpression, prefer_to_contain_default;
var init_prefer_to_contain = __esm({
  "src/rules/prefer-to-contain.ts"() {
    "use strict";
    init_ast();
    init_parseExpectCall();
    matchers = /* @__PURE__ */ new Set(["toBe", "toEqual", "toStrictEqual"]);
    isFixableIncludesCallExpression = (node) => node.type === "CallExpression" && node.callee.type === "MemberExpression" && isPropertyAccessor(node.callee, "includes") && node.arguments.length === 1 && node.arguments[0].type !== "SpreadElement";
    prefer_to_contain_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall || expectCall.args.length === 0)
              return;
            const { args, matcher, matcherName } = expectCall;
            const [includesCall] = node.arguments;
            const [matcherArg] = args;
            if (!includesCall || matcherArg.type === "SpreadElement" || !matchers.has(matcherName) || !isBooleanLiteral(matcherArg) || !isFixableIncludesCallExpression(includesCall)) {
              return;
            }
            const notModifier = expectCall.modifiers.find(
              (node2) => getStringValue(node2) === "not"
            );
            context.report({
              fix(fixer) {
                const sourceCode = context.sourceCode ?? context.getSourceCode();
                const addNotModifier = matcherArg.type === "Literal" && matcherArg.value === !!notModifier;
                const fixes = [
                  // remove the "includes" call entirely
                  fixer.removeRange([
                    includesCall.callee.property.range[0] - 1,
                    includesCall.range[1]
                  ]),
                  // replace the current matcher with "toContain", adding "not" if needed
                  fixer.replaceText(
                    matcher,
                    addNotModifier ? "not.toContain" : "toContain"
                  ),
                  // replace the matcher argument with the value from the "includes"
                  fixer.replaceText(
                    expectCall.args[0],
                    sourceCode.getText(includesCall.arguments[0])
                  )
                ];
                if (notModifier) {
                  fixes.push(
                    fixer.removeRange([
                      notModifier.range[0],
                      notModifier.range[1] + 1
                    ])
                  );
                }
                return fixes;
              },
              messageId: "useToContain",
              node: matcher
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Suggest using toContain()",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-to-contain.md"
        },
        fixable: "code",
        messages: {
          useToContain: "Use toContain() instead"
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-to-have-count.ts
var matchers2, prefer_to_have_count_default;
var init_prefer_to_have_count = __esm({
  "src/rules/prefer-to-have-count.ts"() {
    "use strict";
    init_fixer();
    init_parseExpectCall();
    matchers2 = /* @__PURE__ */ new Set(["toBe", "toEqual", "toStrictEqual"]);
    prefer_to_have_count_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall || !matchers2.has(expectCall.matcherName)) {
              return;
            }
            const [argument] = node.arguments;
            if (argument.type !== "AwaitExpression" || argument.argument.type !== "CallExpression" || argument.argument.callee.type !== "MemberExpression") {
              return;
            }
            const callee = argument.argument.callee;
            context.report({
              fix(fixer) {
                return [
                  // remove the "await" expression
                  fixer.removeRange([
                    argument.range[0],
                    argument.range[0] + "await".length + 1
                  ]),
                  // remove the "count()" method accessor
                  fixer.removeRange([
                    callee.property.range[0] - 1,
                    argument.argument.range[1]
                  ]),
                  // replace the current matcher with "toHaveCount"
                  replaceAccessorFixer(fixer, expectCall.matcher, "toHaveCount"),
                  // insert "await" to before "expect()"
                  fixer.insertTextBefore(node, "await ")
                ];
              },
              messageId: "useToHaveCount",
              node: expectCall.matcher
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Suggest using `toHaveCount()`",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-to-have-count.md"
        },
        fixable: "code",
        messages: {
          useToHaveCount: "Use toHaveCount() instead"
        },
        schema: [],
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-to-have-length.ts
var lengthMatchers, prefer_to_have_length_default;
var init_prefer_to_have_length = __esm({
  "src/rules/prefer-to-have-length.ts"() {
    "use strict";
    init_ast();
    init_fixer();
    init_parseExpectCall();
    lengthMatchers = /* @__PURE__ */ new Set(["toBe", "toEqual", "toStrictEqual"]);
    prefer_to_have_length_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall || !lengthMatchers.has(expectCall.matcherName)) {
              return;
            }
            const [argument] = node.arguments;
            if (argument?.type !== "MemberExpression" || !isPropertyAccessor(argument, "length")) {
              return;
            }
            context.report({
              fix(fixer) {
                return [
                  // remove the "length" property accessor
                  fixer.removeRange([
                    argument.property.range[0] - 1,
                    argument.range[1]
                  ]),
                  // replace the current matcher with "toHaveLength"
                  replaceAccessorFixer(fixer, expectCall.matcher, "toHaveLength")
                ];
              },
              messageId: "useToHaveLength",
              node: expectCall.matcher
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Suggest using `toHaveLength()`",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-to-have-length.md"
        },
        fixable: "code",
        messages: {
          useToHaveLength: "Use toHaveLength() instead"
        },
        schema: [],
        type: "suggestion"
      }
    };
  }
});

// src/rules/prefer-web-first-assertions.ts
var methods3, supportedMatchers, prefer_web_first_assertions_default;
var init_prefer_web_first_assertions = __esm({
  "src/rules/prefer-web-first-assertions.ts"() {
    "use strict";
    init_ast();
    init_parseExpectCall();
    methods3 = {
      getAttribute: {
        matcher: "toHaveAttribute",
        type: "string"
      },
      innerText: { matcher: "toHaveText", type: "string" },
      inputValue: { matcher: "toHaveValue", type: "string" },
      isChecked: { matcher: "toBeChecked", type: "boolean" },
      isDisabled: {
        inverse: "toBeEnabled",
        matcher: "toBeDisabled",
        type: "boolean"
      },
      isEditable: { matcher: "toBeEditable", type: "boolean" },
      isEnabled: {
        inverse: "toBeDisabled",
        matcher: "toBeEnabled",
        type: "boolean"
      },
      isHidden: {
        inverse: "toBeVisible",
        matcher: "toBeHidden",
        type: "boolean"
      },
      isVisible: {
        inverse: "toBeHidden",
        matcher: "toBeVisible",
        type: "boolean"
      },
      textContent: { matcher: "toHaveText", type: "string" }
    };
    supportedMatchers = /* @__PURE__ */ new Set([
      "toBe",
      "toEqual",
      "toBeTruthy",
      "toBeFalsy"
    ]);
    prefer_web_first_assertions_default = {
      create(context) {
        return {
          CallExpression(node) {
            const expectCall = parseExpectCall(node);
            if (!expectCall)
              return;
            const [arg] = node.arguments;
            if (arg.type !== "AwaitExpression" || arg.argument.type !== "CallExpression" || arg.argument.callee.type !== "MemberExpression") {
              return;
            }
            if (!supportedMatchers.has(expectCall.matcherName))
              return;
            const method = getStringValue(arg.argument.callee.property);
            const methodConfig = methods3[method];
            if (!methodConfig)
              return;
            const { args, matcher } = expectCall;
            const notModifier = expectCall.modifiers.find(
              (mod) => getStringValue(mod) === "not"
            );
            const isFalsy = methodConfig.type === "boolean" && (!!args.length && isBooleanLiteral(args[0], false) || expectCall.matcherName === "toBeFalsy");
            const isInverse = methodConfig.inverse ? notModifier || isFalsy : notModifier && isFalsy;
            const newMatcher = +!!notModifier ^ +isFalsy && methodConfig.inverse || methodConfig.matcher;
            const { callee } = arg.argument;
            context.report({
              data: {
                matcher: newMatcher,
                method
              },
              fix: (fixer) => {
                const methodArgs = arg.argument.type === "CallExpression" ? arg.argument.arguments : [];
                const methodEnd = methodArgs.length ? methodArgs[methodArgs.length - 1].range[1] + 1 : callee.property.range[1] + 2;
                const fixes = [
                  // Add await to the expect call
                  fixer.insertTextBefore(node, "await "),
                  // Remove the await keyword
                  fixer.replaceTextRange(
                    [arg.range[0], arg.argument.range[0]],
                    ""
                  ),
                  // Remove the old Playwright method and any arguments
                  fixer.replaceTextRange(
                    [callee.property.range[0] - 1, methodEnd],
                    ""
                  )
                ];
                if (isInverse && notModifier) {
                  const notRange = notModifier.range;
                  fixes.push(fixer.removeRange([notRange[0], notRange[1] + 1]));
                }
                if (!methodConfig.inverse && !notModifier && isFalsy) {
                  fixes.push(fixer.insertTextBefore(matcher, "not."));
                }
                fixes.push(fixer.replaceText(matcher, newMatcher));
                const [matcherArg] = args ?? [];
                if (matcherArg && isBooleanLiteral(matcherArg)) {
                  fixes.push(fixer.remove(matcherArg));
                }
                const hasOtherArgs = !!methodArgs.filter(
                  (arg2) => !isBooleanLiteral(arg2)
                ).length;
                if (methodArgs) {
                  const range = matcher.range;
                  const stringArgs = methodArgs.map((arg2) => getRawValue(arg2)).concat(hasOtherArgs ? "" : []).join(", ");
                  fixes.push(
                    fixer.insertTextAfterRange(
                      [range[0], range[1] + 1],
                      stringArgs
                    )
                  );
                }
                return fixes;
              },
              messageId: "useWebFirstAssertion",
              node
            });
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Prefer web first assertions",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/prefer-web-first-assertions.md"
        },
        fixable: "code",
        messages: {
          useWebFirstAssertion: "Replace {{method}}() with {{matcher}}()."
        },
        type: "suggestion"
      }
    };
  }
});

// src/rules/require-soft-assertions.ts
var require_soft_assertions_default;
var init_require_soft_assertions = __esm({
  "src/rules/require-soft-assertions.ts"() {
    "use strict";
    init_ast();
    require_soft_assertions_default = {
      create(context) {
        return {
          CallExpression(node) {
            if (getExpectType(node) === "standalone") {
              context.report({
                fix: (fixer) => fixer.insertTextAfter(node.callee, ".soft"),
                messageId: "requireSoft",
                node: node.callee
              });
            }
          }
        };
      },
      meta: {
        docs: {
          description: "Require all assertions to use `expect.soft`",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/require-soft-assertions.md"
        },
        fixable: "code",
        messages: {
          requireSoft: "Unexpected non-soft assertion"
        },
        schema: [],
        type: "suggestion"
      }
    };
  }
});

// src/rules/require-top-level-describe.ts
var require_top_level_describe_default;
var init_require_top_level_describe = __esm({
  "src/rules/require-top-level-describe.ts"() {
    "use strict";
    init_ast();
    init_misc();
    require_top_level_describe_default = {
      create(context) {
        const { maxTopLevelDescribes } = {
          maxTopLevelDescribes: Infinity,
          ...context.options?.[0] ?? {}
        };
        let topLevelDescribeCount = 0;
        let describeCount = 0;
        return {
          CallExpression(node) {
            if (isDescribeCall(node)) {
              describeCount++;
              if (describeCount === 1) {
                topLevelDescribeCount++;
                if (topLevelDescribeCount > maxTopLevelDescribes) {
                  context.report({
                    data: getAmountData(maxTopLevelDescribes),
                    messageId: "tooManyDescribes",
                    node: node.callee
                  });
                }
              }
            } else if (!describeCount) {
              if (isTestCall(node)) {
                context.report({ messageId: "unexpectedTest", node: node.callee });
              } else if (isTestHook(node)) {
                context.report({ messageId: "unexpectedHook", node: node.callee });
              }
            }
          },
          "CallExpression:exit"(node) {
            if (isDescribeCall(node)) {
              describeCount--;
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Require test cases and hooks to be inside a `test.describe` block",
          recommended: false,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/require-top-level-describe.md"
        },
        messages: {
          tooManyDescribes: "There should not be more than {{max}} describe{{s}} at the top level",
          unexpectedHook: "All hooks must be wrapped in a describe block.",
          unexpectedTest: "All test cases must be wrapped in a describe block."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              maxTopLevelDescribes: {
                minimum: 1,
                type: "number"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/rules/valid-expect.ts
function isMatcherCalled(node) {
  if (node.parent.type !== "MemberExpression") {
    return {
      called: node.parent.type === "CallExpression" && node.parent.callee === node,
      node
    };
  }
  return isMatcherCalled(node.parent);
}
var valid_expect_default;
var init_valid_expect = __esm({
  "src/rules/valid-expect.ts"() {
    "use strict";
    init_ast();
    init_misc();
    init_parseExpectCall();
    valid_expect_default = {
      create(context) {
        const options = {
          maxArgs: 2,
          minArgs: 1,
          ...context.options?.[0] ?? {}
        };
        const minArgs = Math.min(options.minArgs, options.maxArgs);
        const maxArgs = Math.max(options.minArgs, options.maxArgs);
        return {
          CallExpression(node) {
            if (!isExpectCall(node))
              return;
            const expectCall = parseExpectCall(node);
            if (!expectCall) {
              context.report({ messageId: "matcherNotFound", node });
            } else {
              const result = isMatcherCalled(node);
              if (!result.called) {
                context.report({
                  messageId: "matcherNotCalled",
                  node: result.node.type === "MemberExpression" ? result.node.property : result.node
                });
              }
            }
            if (node.arguments.length < minArgs) {
              context.report({
                data: getAmountData(minArgs),
                messageId: "notEnoughArgs",
                node
              });
            }
            if (node.arguments.length > maxArgs) {
              context.report({
                data: getAmountData(maxArgs),
                messageId: "tooManyArgs",
                node
              });
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Possible Errors",
          description: "Enforce valid `expect()` usage",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/valid-expect.md"
        },
        messages: {
          matcherNotCalled: "Matchers must be called to assert.",
          matcherNotFound: "Expect must have a corresponding matcher call.",
          notEnoughArgs: "Expect requires at least {{amount}} argument{{s}}.",
          tooManyArgs: "Expect takes at most {{amount}} argument{{s}}."
        },
        schema: [
          {
            additionalProperties: false,
            properties: {
              maxArgs: {
                minimum: 1,
                type: "number"
              },
              minArgs: {
                minimum: 1,
                type: "number"
              }
            },
            type: "object"
          }
        ],
        type: "problem"
      }
    };
  }
});

// src/rules/valid-title.ts
var doesBinaryExpressionContainStringNode, quoteStringValue, compileMatcherPattern, compileMatcherPatterns, MatcherAndMessageSchema, valid_title_default;
var init_valid_title = __esm({
  "src/rules/valid-title.ts"() {
    "use strict";
    init_ast();
    doesBinaryExpressionContainStringNode = (binaryExp) => {
      if (isStringNode(binaryExp.right)) {
        return true;
      }
      if (binaryExp.left.type === "BinaryExpression") {
        return doesBinaryExpressionContainStringNode(binaryExp.left);
      }
      return isStringNode(binaryExp.left);
    };
    quoteStringValue = (node) => node.type === "TemplateLiteral" ? `\`${node.quasis[0].value.raw}\`` : node.raw ?? "";
    compileMatcherPattern = (matcherMaybeWithMessage) => {
      const [matcher, message] = Array.isArray(matcherMaybeWithMessage) ? matcherMaybeWithMessage : [matcherMaybeWithMessage];
      return [new RegExp(matcher, "u"), message];
    };
    compileMatcherPatterns = (matchers3) => {
      if (typeof matchers3 === "string" || Array.isArray(matchers3)) {
        const compiledMatcher = compileMatcherPattern(matchers3);
        return {
          describe: compiledMatcher,
          test: compiledMatcher
        };
      }
      return {
        describe: matchers3.describe ? compileMatcherPattern(matchers3.describe) : null,
        test: matchers3.test ? compileMatcherPattern(matchers3.test) : null
      };
    };
    MatcherAndMessageSchema = {
      additionalItems: false,
      items: { type: "string" },
      maxItems: 2,
      minItems: 1,
      type: "array"
    };
    valid_title_default = {
      create(context) {
        const opts = context.options?.[0] ?? {};
        const {
          disallowedWords = [],
          ignoreSpaces = false,
          ignoreTypeOfDescribeName = false,
          ignoreTypeOfTestName = false,
          mustMatch,
          mustNotMatch
        } = opts;
        const disallowedWordsRegexp = new RegExp(
          `\\b(${disallowedWords.join("|")})\\b`,
          "iu"
        );
        const mustNotMatchPatterns = compileMatcherPatterns(mustNotMatch ?? {});
        const mustMatchPatterns = compileMatcherPatterns(mustMatch ?? {});
        return {
          CallExpression(node) {
            const isDescribe = isDescribeCall(node);
            const isTest = isTestCall(node);
            if (!isDescribe && !isTest) {
              return;
            }
            const [argument] = node.arguments;
            if (!argument) {
              return;
            }
            if (!isStringNode(argument)) {
              if (argument.type === "BinaryExpression" && doesBinaryExpressionContainStringNode(argument)) {
                return;
              }
              if (!(isDescribe && ignoreTypeOfDescribeName || isTest && ignoreTypeOfTestName) && argument.type !== "TemplateLiteral") {
                context.report({
                  loc: argument.loc,
                  messageId: "titleMustBeString"
                });
              }
              return;
            }
            const title = getStringValue(argument);
            const functionName = isDescribe ? "describe" : "test";
            if (!title) {
              context.report({
                data: { functionName },
                messageId: "emptyTitle",
                node
              });
              return;
            }
            if (disallowedWords.length > 0) {
              const disallowedMatch = disallowedWordsRegexp.exec(title);
              if (disallowedMatch) {
                context.report({
                  data: { word: disallowedMatch[1] },
                  messageId: "disallowedWord",
                  node: argument
                });
                return;
              }
            }
            if (ignoreSpaces === false && title.trim().length !== title.length) {
              context.report({
                fix: (fixer) => [
                  fixer.replaceTextRange(
                    argument.range,
                    quoteStringValue(argument).replace(/^([`'"]) +?/u, "$1").replace(/ +?([`'"])$/u, "$1")
                  )
                ],
                messageId: "accidentalSpace",
                node: argument
              });
            }
            const [firstWord] = title.split(" ");
            if (firstWord.toLowerCase() === functionName) {
              context.report({
                fix: (fixer) => [
                  fixer.replaceTextRange(
                    argument.range,
                    quoteStringValue(argument).replace(/^([`'"]).+? /u, "$1")
                  )
                ],
                messageId: "duplicatePrefix",
                node: argument
              });
            }
            const [mustNotMatchPattern, mustNotMatchMessage] = mustNotMatchPatterns[functionName] ?? [];
            if (mustNotMatchPattern && mustNotMatchPattern.test(title)) {
              context.report({
                data: {
                  functionName,
                  message: mustNotMatchMessage ?? "",
                  pattern: String(mustNotMatchPattern)
                },
                messageId: mustNotMatchMessage ? "mustNotMatchCustom" : "mustNotMatch",
                node: argument
              });
              return;
            }
            const [mustMatchPattern, mustMatchMessage] = mustMatchPatterns[functionName] ?? [];
            if (mustMatchPattern && !mustMatchPattern.test(title)) {
              context.report({
                data: {
                  functionName,
                  message: mustMatchMessage ?? "",
                  pattern: String(mustMatchPattern)
                },
                messageId: mustMatchMessage ? "mustMatchCustom" : "mustMatch",
                node: argument
              });
              return;
            }
          }
        };
      },
      meta: {
        docs: {
          category: "Best Practices",
          description: "Enforce valid titles",
          recommended: true,
          url: "https://github.com/playwright-community/eslint-plugin-playwright/tree/main/docs/rules/valid-title.md"
        },
        fixable: "code",
        messages: {
          accidentalSpace: "should not have leading or trailing spaces",
          disallowedWord: '"{{ word }}" is not allowed in test titles',
          duplicatePrefix: "should not have duplicate prefix",
          emptyTitle: "{{ functionName }} should not have an empty title",
          mustMatch: "{{ functionName }} should match {{ pattern }}",
          mustMatchCustom: "{{ message }}",
          mustNotMatch: "{{ functionName }} should not match {{ pattern }}",
          mustNotMatchCustom: "{{ message }}",
          titleMustBeString: "Title must be a string"
        },
        schema: [
          {
            additionalProperties: false,
            patternProperties: {
              [/^must(?:Not)?Match$/u.source]: {
                oneOf: [
                  { type: "string" },
                  MatcherAndMessageSchema,
                  {
                    additionalProperties: {
                      oneOf: [{ type: "string" }, MatcherAndMessageSchema]
                    },
                    propertyNames: { enum: ["describe", "test"] },
                    type: "object"
                  }
                ]
              }
            },
            properties: {
              disallowedWords: {
                items: { type: "string" },
                type: "array"
              },
              ignoreSpaces: {
                default: false,
                type: "boolean"
              },
              ignoreTypeOfDescribeName: {
                default: false,
                type: "boolean"
              },
              ignoreTypeOfTestName: {
                default: false,
                type: "boolean"
              }
            },
            type: "object"
          }
        ],
        type: "suggestion"
      }
    };
  }
});

// src/index.ts
import globals from "globals";
var require_src = __commonJS({
  "src/index.ts"(exports, module) {
    init_expect_expect();
    init_max_nested_describe();
    init_missing_playwright_await();
    init_no_conditional_in_test();
    init_no_element_handle();
    init_no_eval();
    init_no_focused_test();
    init_no_force_option();
    init_no_nested_step();
    init_no_networkidle();
    init_no_nth_methods();
    init_no_page_pause();
    init_no_raw_locators();
    init_no_restricted_matchers();
    init_no_skipped_test();
    init_no_useless_await();
    init_no_useless_not();
    init_no_wait_for_selector();
    init_no_wait_for_timeout();
    init_prefer_lowercase_title();
    init_prefer_strict_equal();
    init_prefer_to_be();
    init_prefer_to_contain();
    init_prefer_to_have_count();
    init_prefer_to_have_length();
    init_prefer_web_first_assertions();
    init_require_soft_assertions();
    init_require_top_level_describe();
    init_valid_expect();
    init_valid_title();
    var index = {
      configs: {},
      rules: {
        "expect-expect": expect_expect_default,
        "max-nested-describe": max_nested_describe_default,
        "missing-playwright-await": missing_playwright_await_default,
        "no-conditional-in-test": no_conditional_in_test_default,
        "no-element-handle": no_element_handle_default,
        "no-eval": no_eval_default,
        "no-focused-test": no_focused_test_default,
        "no-force-option": no_force_option_default,
        "no-nested-step": no_nested_step_default,
        "no-networkidle": no_networkidle_default,
        "no-nth-methods": no_nth_methods_default,
        "no-page-pause": no_page_pause_default,
        "no-raw-locators": no_raw_locators_default,
        "no-restricted-matchers": no_restricted_matchers_default,
        "no-skipped-test": no_skipped_test_default,
        "no-useless-await": no_useless_await_default,
        "no-useless-not": no_useless_not_default,
        "no-wait-for-selector": no_wait_for_selector_default,
        "no-wait-for-timeout": no_wait_for_timeout_default,
        "prefer-lowercase-title": prefer_lowercase_title_default,
        "prefer-strict-equal": prefer_strict_equal_default,
        "prefer-to-be": prefer_to_be_default,
        "prefer-to-contain": prefer_to_contain_default,
        "prefer-to-have-count": prefer_to_have_count_default,
        "prefer-to-have-length": prefer_to_have_length_default,
        "prefer-web-first-assertions": prefer_web_first_assertions_default,
        "require-soft-assertions": require_soft_assertions_default,
        "require-top-level-describe": require_top_level_describe_default,
        "valid-expect": valid_expect_default,
        "valid-title": valid_title_default
      }
    };
    var sharedConfig = {
      rules: {
        "no-empty-pattern": "off",
        "playwright/expect-expect": "warn",
        "playwright/max-nested-describe": "warn",
        "playwright/missing-playwright-await": "error",
        "playwright/no-conditional-in-test": "warn",
        "playwright/no-element-handle": "warn",
        "playwright/no-eval": "warn",
        "playwright/no-focused-test": "error",
        "playwright/no-force-option": "warn",
        "playwright/no-nested-step": "warn",
        "playwright/no-networkidle": "error",
        "playwright/no-page-pause": "warn",
        "playwright/no-skipped-test": "warn",
        "playwright/no-useless-await": "warn",
        "playwright/no-useless-not": "warn",
        "playwright/no-wait-for-selector": "warn",
        "playwright/no-wait-for-timeout": "warn",
        "playwright/prefer-web-first-assertions": "error",
        "playwright/valid-expect": "error",
        "playwright/valid-title": "error"
      }
    };
    var legacyConfig = {
      ...sharedConfig,
      env: {
        "shared-node-browser": true
      },
      plugins: ["playwright"]
    };
    var flatConfig = {
      ...sharedConfig,
      languageOptions: {
        globals: globals["shared-node-browser"]
      },
      plugins: {
        playwright: index
      }
    };
    var sharedJestConfig = {
      rules: {
        "jest/no-standalone-expect": [
          "error",
          {
            additionalTestBlockFunctions: [
              "test.jestPlaywrightDebug",
              "it.jestPlaywrightDebug",
              "test.jestPlaywrightSkip",
              "it.jestPlaywrightSkip",
              "test.jestPlaywrightConfig",
              "it.jestPlaywrightConfig"
            ]
          }
        ],
        "playwright/missing-playwright-await": "error",
        "playwright/no-page-pause": "warn"
      }
    };
    var legacyJestConfig = {
      ...sharedJestConfig,
      env: {
        jest: true,
        "shared-node-browser": true
      },
      globals: {
        browser: true,
        browserName: true,
        context: true,
        deviceName: true,
        jestPlaywright: true,
        page: true
      },
      plugins: ["jest", "playwright"]
    };
    var jestConfig = {
      ...sharedJestConfig,
      languageOptions: {
        globals: {
          ...globals["shared-node-browser"],
          ...globals.jest,
          browser: "writable",
          browserName: "writable",
          context: "writable",
          deviceName: "writable",
          jestPlaywright: "writable",
          page: "writable"
        }
      },
      plugins: {
        playwright: index
      }
    };
    module.exports = {
      ...index,
      configs: {
        "flat/jest-playwright": jestConfig,
        "flat/recommended": flatConfig,
        "jest-playwright": legacyJestConfig,
        "playwright-test": legacyConfig,
        recommended: legacyConfig
      }
    };
  }
});
export default require_src();
